{% set routes = selected_goal.routes if selected_goal else [] %}
{% set decisions = selected_goal.decisions if selected_goal else [] %}
{% set active_path = path_routes if path_routes is defined else (selected_goal.selected_path_routes() if selected_goal else []) %}

{% set active_ids = [] %}
{% for r in active_path %}
  {% set _ = active_ids.append(r.id|string) %}
{% endfor %}

{% set meta = namespace(max_phase=0) %}
{% for r in routes %}
  {% if (r.phase or 0) > meta.max_phase %}{% set meta.max_phase = (r.phase or 0) %}{% endif %}
{% endfor %}
{% for d in decisions %}
  {% if (d.phase or 0) > meta.max_phase %}{% set meta.max_phase = (d.phase or 0) %}{% endif %}
{% endfor %}

{% set phase_count = (meta.max_phase + 1) if (routes|length > 0 or decisions|length > 0) else 1 %}
{% set x0 = 70 %}
{% set phase_w = 220 %}
{% set vb_w = x0 + (phase_count * phase_w) + 110 %}
{% set vb_h = 280 %}
{% set y_trunk = 150 %}

<div class="track-wrap">
  <div class="track-legend">
    <span class="pill">Linien = Abschnitte/Abzweige</span>
    <span class="pill">Grün = erledigte Arbeitspakete</span>
    <span class="pill">Hervorhebung = aktiver Pfad</span>
  </div>

  {% if selected_goal and selected_goal.edges and selected_goal.edges|length > 0 %}
    {#
      DAG-Visualisierung (generisch): routes = nodes, edges = Kanten.
      Layout/Rendering machen wir in JS, um tiefe Verzweigungen + Merges einfach zu zeichnen.
    #}

    {% set js_routes = [] %}
    {% for r in routes %}
      {% set cnt = namespace(total=0, done=0) %}
      {% for t in r.tasks %}
        {% for wp in t.work_packages %}
          {% set cnt.total = cnt.total + 1 %}
          {% if wp.status.value == 'done' %}{% set cnt.done = cnt.done + 1 %}{% endif %}
        {% endfor %}
      {% endfor %}
      {% set ratio = (cnt.done / cnt.total) if cnt.total > 0 else 0 %}
      {% set _ = js_routes.append({'id': r.id|string, 'title': r.title, 'kind': r.kind.value, 'ratio': ratio}) %}
    {% endfor %}

    {% set js_edges = [] %}
    {% for e in selected_goal.edges %}
      {% set _ = js_edges.append({'from': e.from_route_id|string, 'to': e.to_route_id|string}) %}
    {% endfor %}

    {% set js_active_pairs = [] %}
    {% for r in active_path %}
      {% if not loop.first %}
        {% set _ = js_active_pairs.append({'from': active_path[loop.index0 - 1].id|string, 'to': r.id|string}) %}
      {% endif %}
    {% endfor %}

    <svg id="dag-track" class="track" viewBox="0 0 700 320" preserveAspectRatio="xMinYMin meet" role="img" aria-label="Plan als Liniengraph (DAG) mit Weichen und Merge"></svg>

    <script>
      (() => {
        const svg = document.getElementById('dag-track');
        if (!svg) return;

        const routes = {{ js_routes|tojson }};
        const edges = {{ js_edges|tojson }};
        const activeIds = new Set({{ active_ids|tojson }});
        const activePairs = new Set(({{ js_active_pairs|tojson }}).map(p => `${p.from}→${p.to}`));

        const ns = 'http://www.w3.org/2000/svg';
        const el = (name, attrs = {}) => {
          const n = document.createElementNS(ns, name);
          for (const [k, v] of Object.entries(attrs)) {
            n.setAttribute(k, String(v));
          }
          return n;
        };

        // Build adjacency
        const nodes = new Map();
        for (const r of routes) nodes.set(r.id, { ...r, out: [], incoming: 0 });

        const incomingAdj = new Map();
        for (const id of nodes.keys()) incomingAdj.set(id, []);

        for (const e of edges) {
          if (!nodes.has(e.from) || !nodes.has(e.to)) continue;
          nodes.get(e.from).out.push(e.to);
          nodes.get(e.to).incoming += 1;
          incomingAdj.get(e.to).push(e.from);
        }

        // Kahn topological order (best effort)
        const q = [];
        for (const [id, n] of nodes.entries()) {
          if (n.incoming === 0) q.push(id);
        }
        const topo = [];
        const incomingLeft = new Map();
        for (const [id, n] of nodes.entries()) incomingLeft.set(id, n.incoming);

        while (q.length) {
          const id = q.shift();
          topo.push(id);
          for (const to of nodes.get(id).out) {
            incomingLeft.set(to, (incomingLeft.get(to) || 0) - 1);
            if (incomingLeft.get(to) === 0) q.push(to);
          }
        }

        if (topo.length !== nodes.size) {
          // Fallback: still render something even if the graph isn't strictly a DAG.
          topo.length = 0;
          for (const id of nodes.keys()) topo.push(id);
        }

        // Depth (layer) = longest path from any root.
        const depth = new Map();
        for (const id of topo) {
          const parents = incomingAdj.get(id) || [];
          let d = 0;
          for (const p of parents) d = Math.max(d, (depth.get(p) || 0) + 1);
          depth.set(id, d);
        }

        let maxDepth = 0;
        for (const d of depth.values()) maxDepth = Math.max(maxDepth, d);

        // Layout constants
        const marginX = 70;
        const marginY = 40;
        const colW = 220;
        const rowGap = 70;
        const segLen = 130;

        // Build layers
        const layers = [];
        for (let i = 0; i <= maxDepth; i++) layers.push([]);
        for (const id of topo) {
          const d = depth.get(id) || 0;
          if (!layers[d]) layers[d] = [];
          layers[d].push(id);
        }

        let maxInLayer = 1;
        for (const layer of layers) maxInLayer = Math.max(maxInLayer, layer.length || 1);

        const vbW = marginX + (maxDepth + 1) * colW + 110;
        const vbH = Math.max(260, marginY * 2 + (maxInLayer - 1) * rowGap + 90);
        svg.setAttribute('viewBox', `0 0 ${vbW} ${vbH}`);

        // Compute coordinates
        const pos = new Map();
        for (let d = 0; d < layers.length; d++) {
          const layer = layers[d] || [];
          const count = layer.length || 1;
          const layerHeight = (count - 1) * rowGap;
          const startY = (vbH - layerHeight) / 2;
          for (let i = 0; i < layer.length; i++) {
            const id = layer[i];
            const x = marginX + d * colW;
            const y = startY + i * rowGap;
            pos.set(id, { x, y });
          }
        }

        // Draw connector edges first
        for (const e of edges) {
          const a = pos.get(e.from);
          const b = pos.get(e.to);
          if (!a || !b) continue;

          const key = `${e.from}→${e.to}`;
          const cls = activePairs.has(key) ? 'graph-branch active' : 'graph-branch';
          svg.appendChild(
            el('line', {
              x1: a.x + segLen / 2,
              y1: a.y,
              x2: b.x - segLen / 2,
              y2: b.y,
              class: cls,
            })
          );
        }

        // Draw nodes as route segments with progress overlay
        for (const r of routes) {
          const p = pos.get(r.id);
          if (!p) continue;

          const isActive = activeIds.has(r.id);
          const baseCls = isActive ? 'graph-line active' : 'graph-line';
          const doneCls = isActive ? 'graph-done active' : 'graph-done';
          const x1 = p.x - segLen / 2;
          const x2 = p.x + segLen / 2;
          const xDone = x1 + (segLen * Math.max(0, Math.min(1, r.ratio || 0)));

          svg.appendChild(el('line', { x1, y1: p.y, x2, y2: p.y, class: baseCls }));
          svg.appendChild(el('line', { x1, y1: p.y, x2: xDone, y2: p.y, class: doneCls }));
          svg.appendChild(el('circle', { cx: p.x, cy: p.y, r: 7, class: 'graph-node' }));

          const label = el('text', { x: x1 + 8, y: p.y - 14, class: r.kind === 'branch' ? 'graph-branch-label' : 'graph-label' });
          label.textContent = r.title;
          svg.appendChild(label);
        }
      })();
    </script>
  {% else %}

  <svg class="track" viewBox="0 0 {{ vb_w }} {{ vb_h }}" preserveAspectRatio="xMinYMin meet" role="img" aria-label="Plan als Liniengraph mit Weichen und Merge">

    {% if phase_count == 1 and routes|length == 0 %}
      <text x="20" y="40" class="muted-svg">Noch keine Strecke. Erstelle einen Plan.</text>
    {% endif %}

    {% for phase in range(0, phase_count) %}
      {% set x1 = x0 + (phase * phase_w) %}
      {% set x2 = x1 + phase_w %}
      {% set x_mid = x1 + (phase_w * 0.55) %}

      {% set ph = namespace(trunk=none, branches=[], decision=none) %}
      {% for r in routes %}
        {% if (r.phase or 0) == phase %}
          {% if r.kind.value == 'trunk' and ph.trunk is none %}
            {% set ph.trunk = r %}
          {% elif r.kind.value == 'branch' %}
            {% set _ = ph.branches.append(r) %}
          {% endif %}
        {% endif %}
      {% endfor %}

      {% for dd in decisions %}
        {% if (dd.phase or 0) == phase %}
          {% set ph.decision = dd %}
        {% endif %}
      {% endfor %}

      <!-- Phase marker -->
      <circle cx="{{ x1 }}" cy="{{ y_trunk }}" r="7" class="graph-node" />
      <text x="{{ x1 - 10 }}" y="{{ y_trunk + 32 }}" class="graph-phase">{{ phase + 1 }}</text>

      {% if ph.trunk %}
        {% set cnt = namespace(total=0, done=0) %}
        {% for t in ph.trunk.tasks %}
          {% for wp in t.work_packages %}
            {% set cnt.total = cnt.total + 1 %}
            {% if wp.status.value == 'done' %}{% set cnt.done = cnt.done + 1 %}{% endif %}
          {% endfor %}
        {% endfor %}
        {% set ratio = (cnt.done / cnt.total) if cnt.total > 0 else 0 %}
        {% set is_active = (ph.trunk.id in active_ids) %}

        <line x1="{{ x1 }}" y1="{{ y_trunk }}" x2="{{ x2 }}" y2="{{ y_trunk }}" class="graph-line{% if is_active %} active{% endif %}" />
        <line x1="{{ x1 }}" y1="{{ y_trunk }}" x2="{{ x1 + (phase_w * ratio) }}" y2="{{ y_trunk }}" class="graph-done{% if is_active %} active{% endif %}" />
        <text x="{{ x1 + 8 }}" y="{{ y_trunk - 16 }}" class="graph-label">{{ ph.trunk.title }}</text>
      {% else %}
        <line x1="{{ x1 }}" y1="{{ y_trunk }}" x2="{{ x2 }}" y2="{{ y_trunk }}" class="graph-line missing" />
      {% endif %}

      {% if ph.decision and ph.branches|length > 0 %}
        {% set ch = namespace(route_id=none) %}
        {% set chosen_opt = ph.decision.chosen_option_id or (ph.decision.options[0].id if ph.decision.options|length > 0 else none) %}
        {% for opt in ph.decision.options %}
          {% if chosen_opt and opt.id == chosen_opt %}{% set ch.route_id = opt.route_id %}{% endif %}
        {% endfor %}

        {% set positions = [] %}
        {% if ph.branches|length == 1 %}
          {% set _ = positions.append(y_trunk - 70) %}
        {% elif ph.branches|length == 2 %}
          {% set _ = positions.append(y_trunk - 70) %}
          {% set _ = positions.append(y_trunk + 70) %}
        {% else %}
          {% set _ = positions.append(y_trunk - 90) %}
          {% set _ = positions.append(y_trunk - 20) %}
          {% set _ = positions.append(y_trunk + 60) %}
        {% endif %}

        {% for br in ph.branches %}
          {% set yb = positions[loop.index0] if loop.index0 < positions|length else (y_trunk + (loop.index0 * 70)) %}
          {% set is_active = (br.id in active_ids) %}
          {% set is_chosen = (ch.route_id and br.id == ch.route_id) %}

          {% set cntb = namespace(total=0, done=0) %}
          {% for t in br.tasks %}
            {% for wp in t.work_packages %}
              {% set cntb.total = cntb.total + 1 %}
              {% if wp.status.value == 'done' %}{% set cntb.done = cntb.done + 1 %}{% endif %}
            {% endfor %}
          {% endfor %}
          {% set ratio_b = (cntb.done / cntb.total) if cntb.total > 0 else 0 %}

          <!-- branch out -->
          <line x1="{{ x_mid - 10 }}" y1="{{ y_trunk }}" x2="{{ x_mid + 18 }}" y2="{{ yb }}" class="graph-branch{% if is_active %} active{% endif %}{% if is_chosen %} chosen{% endif %}" />
          <!-- branch horizontal -->
          <line x1="{{ x_mid + 18 }}" y1="{{ yb }}" x2="{{ x2 - 24 }}" y2="{{ yb }}" class="graph-branch{% if is_active %} active{% endif %}{% if is_chosen %} chosen{% endif %}" />
          <line x1="{{ x_mid + 18 }}" y1="{{ yb }}" x2="{{ x_mid + 18 + ((x2 - 24) - (x_mid + 18)) * ratio_b }}" y2="{{ yb }}" class="graph-done{% if is_active %} active{% endif %}" />
          <!-- merge back -->
          <line x1="{{ x2 - 24 }}" y1="{{ yb }}" x2="{{ x2 }}" y2="{{ y_trunk }}" class="graph-branch{% if is_active %} active{% endif %}{% if is_chosen %} chosen{% endif %}" />

          <text x="{{ x_mid + 22 }}" y="{{ yb - 12 }}" class="graph-branch-label">{{ br.title }}</text>
        {% endfor %}
      {% endif %}
    {% endfor %}

    <!-- end marker -->
    <circle cx="{{ x0 + (phase_count * phase_w) }}" cy="{{ y_trunk }}" r="7" class="graph-node" />
  </svg>
  {% endif %}
</div>
